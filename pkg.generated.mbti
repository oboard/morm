// Generated using `moon info`, DON'T EDIT IT
package "oboard/morm"

import(
  "moonbitlang/core/json"
  "oboard/morm/engine"
)

// Values
fn add_column(Table, Column) -> Table

fn add_foreign_key(Table, ForeignKey) -> Table

fn add_index(Table, Index) -> Table

fn alter_table(String) -> AlterTable

fn[E : @engine.Engine, T : Entity] auto_migrate(E, Array[T]) -> Unit

fn begin_tx(Dialect) -> String

fn commit_tx(Dialect) -> String

fn delete_from(String) -> DeleteQuery

fn infer_column_type(Json) -> ColumnType

fn insert_into(String) -> InsertQuery

fn on_delete_cascade(ForeignKey) -> ForeignKey

fn on_update_cascade(ForeignKey) -> ForeignKey

fn rollback_tx(Dialect) -> String

fn select_from(String) -> Query

fn select_raw(String, String) -> Query

fn table_comment(Table, String) -> Table

fn table_engine(Table, String) -> Table

fn update(String) -> UpdateQuery

// Errors

// Types and methods
pub enum AlterOp {
  AddColumn(Column)
  DropColumn(String)
  ModifyColumn(Column)
  AddIndex(Index)
  DropIndex(String)
  AddForeignKey(ForeignKey)
  DropForeignKey(String)
  RenameTable(String)
  TableComment(String)
}
impl Show for AlterOp
impl ToJson for AlterOp
impl @json.FromJson for AlterOp

pub struct AlterTable {
  table : String
  ops : FixedArray[AlterOp]
}
fn AlterTable::add_column(Self, Column) -> Self
fn AlterTable::add_foreign_key(Self, ForeignKey) -> Self
fn AlterTable::add_index(Self, Index) -> Self
fn AlterTable::comment(Self, String) -> Self
fn AlterTable::drop_column(Self, String) -> Self
fn AlterTable::drop_foreign_key(Self, String) -> Self
fn AlterTable::drop_index(Self, String) -> Self
fn AlterTable::modify_column(Self, Column) -> Self
fn AlterTable::rename(Self, String) -> Self
fn AlterTable::to(Self, Dialect) -> String
impl Show for AlterTable
impl ToJson for AlterTable
impl @json.FromJson for AlterTable

pub(all) struct Column {
  name : String
  column_type : ColumnType
  size : Int
  nullable : Bool
  default_value : String?
  auto_increment : Bool
  primary_key : Bool
  unique : Bool
  comment : String
  charset : String?
  collation : String?
}
fn Column::new(String, ColumnType) -> Self
impl Compare for Column
impl Eq for Column
impl Hash for Column
impl Show for Column
impl ToJson for Column
impl @json.FromJson for Column

pub(all) enum ColumnType {
  TinyInt
  SmallInt
  MediumInt
  Int
  BigInt
  Float
  Double
  Decimal(Int, Int)
  Char(Int)
  VarChar(Int)
  Text
  MediumText
  LongText
  Binary(Int)
  VarBinary(Int)
  Blob
  MediumBlob
  LongBlob
  Date
  Time
  DateTime
  Timestamp
  Year
  Json
  JsonB
  Boolean
}
impl Compare for ColumnType
impl Eq for ColumnType
impl Hash for ColumnType
impl Show for ColumnType
impl ToJson for ColumnType
impl @json.FromJson for ColumnType

pub(all) struct DbError {
  message : String
}
impl Show for DbError
impl ToJson for DbError

pub struct DeleteQuery {
  from : String
  where_ : FixedArray[Where]
}
fn DeleteQuery::to(Self, Dialect) -> String
fn DeleteQuery::where_eq(Self, String, Json) -> Self
fn DeleteQuery::where_gt(Self, String, Json) -> Self
fn DeleteQuery::where_gte(Self, String, Json) -> Self
fn DeleteQuery::where_lt(Self, String, Json) -> Self
fn DeleteQuery::where_lte(Self, String, Json) -> Self
impl Eq for DeleteQuery
impl Show for DeleteQuery
impl ToJson for DeleteQuery
impl @json.FromJson for DeleteQuery

pub(all) enum Dialect {
  MySQL
  Sqlite3
  PgSQL
  SqlServer
  Oracle
}
impl Compare for Dialect
impl Eq for Dialect
impl Hash for Dialect
impl Show for Dialect
impl ToJson for Dialect
impl @json.FromJson for Dialect

pub(all) struct ForeignKey {
  name : String
  column : String
  referenced_table : String
  referenced_column : String
  on_delete : String
  on_update : String
}
fn ForeignKey::new(String, String, String, String) -> Self
impl Compare for ForeignKey
impl Eq for ForeignKey
impl Hash for ForeignKey
impl Show for ForeignKey
impl ToJson for ForeignKey
impl @json.FromJson for ForeignKey

pub(all) struct Index {
  name : String
  index_type : IndexType
  columns : FixedArray[String]
  comment : String
}
fn Index::new(String, FixedArray[String]) -> Self
fn Index::new_primary(FixedArray[String]) -> Self
fn Index::new_unique(String, FixedArray[String]) -> Self
impl Compare for Index
impl Eq for Index
impl Hash for Index
impl Show for Index
impl ToJson for Index
impl @json.FromJson for Index

pub(all) enum IndexType {
  Primary
  Unique
  Index
  FullText
  Spatial
}
impl Compare for IndexType
impl Eq for IndexType
impl Hash for IndexType
impl Show for IndexType
impl ToJson for IndexType
impl @json.FromJson for IndexType

pub struct InsertQuery {
  into : String
  columns : FixedArray[String]
  values : FixedArray[Json]
}
fn InsertQuery::columns(Self, FixedArray[String]) -> Self
fn InsertQuery::to(Self, Dialect) -> String
fn InsertQuery::values(Self, FixedArray[Json]) -> Self
impl Eq for InsertQuery
impl Show for InsertQuery
impl ToJson for InsertQuery
impl @json.FromJson for InsertQuery

pub(all) enum OrderBy {
  Asc(String)
  Desc(String)
}
impl Eq for OrderBy
impl Show for OrderBy
impl ToJson for OrderBy
impl @json.FromJson for OrderBy

pub struct Query {
  select : String
  from : String
  where_ : FixedArray[Where]
  order_by : FixedArray[OrderBy]
  limit : Int?
  offset : Int?
}
fn Query::limit(Self, Int) -> Self
fn Query::offset(Self, Int) -> Self
fn Query::order_by(Self, OrderBy) -> Self
fn Query::page(Self, Int, Int) -> Self
fn Query::to(Self, Dialect) -> String
fn Query::where_eq(Self, String, Json) -> Self
fn Query::where_gt(Self, String, Json) -> Self
fn Query::where_gte(Self, String, Json) -> Self
fn Query::where_lt(Self, String, Json) -> Self
fn Query::where_lte(Self, String, Json) -> Self
impl Eq for Query
impl Show for Query
impl ToJson for Query
impl @json.FromJson for Query

pub struct Set {
  col : String
  value : Json
}
impl Eq for Set
impl Show for Set
impl ToJson for Set
impl @json.FromJson for Set

pub(all) struct Table {
  name : String
  columns : FixedArray[Column]
  indexes : FixedArray[Index]
  foreign_keys : FixedArray[ForeignKey]
  engine : String
  charset : String
  collation : String
  comment : String
  auto_increment : Int
}
fn Table::new(String, columns? : FixedArray[Column]) -> Self
fn Table::to_create_sql(Self, Dialect) -> String
impl Compare for Table
impl Eq for Table
impl Hash for Table
impl Show for Table
impl ToJson for Table
impl @json.FromJson for Table

pub struct UpdateQuery {
  table : String
  sets : FixedArray[Set]
  where_ : FixedArray[Where]
}
fn UpdateQuery::set(Self, String, Json) -> Self
fn UpdateQuery::to(Self, Dialect) -> String
fn UpdateQuery::to_mysql_sql(Self) -> String
fn UpdateQuery::where_eq(Self, String, Json) -> Self
fn UpdateQuery::where_gt(Self, String, Json) -> Self
fn UpdateQuery::where_gte(Self, String, Json) -> Self
fn UpdateQuery::where_lt(Self, String, Json) -> Self
fn UpdateQuery::where_lte(Self, String, Json) -> Self
impl Eq for UpdateQuery
impl Show for UpdateQuery
impl ToJson for UpdateQuery
impl @json.FromJson for UpdateQuery

pub struct Where {
  col : String
  value : Json
  ty : WhereType
}
impl Eq for Where
impl Show for Where
impl ToJson for Where
impl @json.FromJson for Where

pub enum WhereType {
  Eq
  Gt
  Lt
  Gte
  Lte
}
impl Eq for WhereType
impl Show for WhereType
impl ToJson for WhereType
impl @json.FromJson for WhereType

// Type aliases
pub type DbResult[T] = Result[T, DbError]

// Traits
pub(open) trait Driver {
  open(Self, String) -> Result[Self, DbError]
  close(Self) -> Result[Self, DbError]
  ping(Self) -> Result[Unit, DbError]
  exec(Self, String, FixedArray[Json]) -> Result[Unit, DbError]
  query(Self, String, FixedArray[Json]) -> Result[FixedArray[Json], DbError]
}

pub(open) trait Entity : ToJson + @json.FromJson {
  table(Self) -> Table
}

